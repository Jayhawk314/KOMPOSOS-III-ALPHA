"""
Prediction dataclass and enums for KOMPOSOS-III Oracle.
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, Optional
from datetime import datetime


class PredictionType(Enum):
    """Types of predictions the Oracle can make."""

    # From Kan Extension
    KAN_EXTENSION = "kan_extension"

    # From Semantic Analysis
    SEMANTIC_SIMILARITY = "semantic_similarity"
    SEMANTIC_GAP = "semantic_gap"

    # From Temporal Reasoning
    TEMPORAL_INFLUENCE = "temporal_influence"
    TEMPORAL_COLLABORATION = "temporal_collaboration"

    # From Type Heuristics
    TYPE_CONSTRAINED = "type_constrained"

    # From Yoneda Pattern
    YONEDA_ANALOGY = "yoneda_analogy"
    STRUCTURAL_SIMILARITY = "structural_similarity"

    # From Composition
    COMPOSED_MORPHISM = "composed_morphism"
    TRANSITIVE_CLOSURE = "transitive_closure"

    # From Fibration Lift
    CARTESIAN_LIFT = "cartesian_lift"
    FIBER_PREDICTION = "fiber_prediction"

    # From Structural Holes
    TRIANGLE_CLOSURE = "triangle_closure"
    STRUCTURAL_HOLE = "structural_hole"

    # From Geometric Analysis (Ricci Curvature)
    GEOMETRIC = "geometric"
    CURVATURE_BRIDGE = "curvature_bridge"
    SAME_REGION = "same_region"

    # Meta
    ENSEMBLE = "ensemble"  # Combined from multiple strategies


class ConfidenceLevel(Enum):
    """Confidence levels for predictions."""

    CERTAIN = 0.95      # Universal property, mathematical necessity
    HIGH = 0.80         # Strong structural evidence
    MEDIUM = 0.60       # Reasonable inference
    LOW = 0.40          # Speculative
    UNCERTAIN = 0.20    # Weak evidence


@dataclass
class Prediction:
    """
    A prediction generated by the Oracle.

    Predictions are typed, ranked by confidence, and traceable
    back to the strategy that generated them.
    """

    # Core prediction
    source: str                         # Source object name
    target: str                         # Target object name
    predicted_relation: str             # Predicted morphism type (e.g., "influenced")

    # Metadata
    prediction_type: PredictionType     # What kind of prediction
    strategy_name: str                  # Which strategy generated this
    confidence: float                   # 0.0 to 1.0

    # Explanation
    reasoning: str                      # Human-readable explanation
    evidence: Dict[str, Any] = field(default_factory=dict)  # Supporting data

    # Validation
    validated: Optional[bool] = None    # True if confirmed, False if rejected, None if unknown
    validation_source: Optional[str] = None  # How it was validated

    # Timestamps
    created_at: datetime = field(default_factory=datetime.now)

    @property
    def description(self) -> str:
        """Human-readable prediction description."""
        return f"{self.source} may have {self.predicted_relation} {self.target}"

    @property
    def key(self) -> tuple:
        """Unique key for deduplication."""
        return (self.source, self.target, self.predicted_relation)

    def with_adjusted_confidence(self, new_confidence: float) -> 'Prediction':
        """Return a copy with adjusted confidence."""
        return Prediction(
            source=self.source,
            target=self.target,
            predicted_relation=self.predicted_relation,
            prediction_type=self.prediction_type,
            strategy_name=self.strategy_name,
            confidence=new_confidence,
            reasoning=self.reasoning,
            evidence=self.evidence,
            validated=self.validated,
            validation_source=self.validation_source,
            created_at=self.created_at,
        )

    def merge_with(self, other: 'Prediction') -> 'Prediction':
        """
        Merge two predictions of the same key.

        Combines confidence using weighted average based on strategy diversity.
        """
        if self.key != other.key:
            raise ValueError("Cannot merge predictions with different keys")

        # Combine confidence (average, with bonus for multiple strategies)
        combined_confidence = (self.confidence + other.confidence) / 2
        # Bonus for independent confirmation
        if self.strategy_name != other.strategy_name:
            combined_confidence = min(0.98, combined_confidence * 1.1)

        # Combine evidence
        merged_evidence = {**self.evidence, **other.evidence}
        merged_evidence["merged_from"] = [self.strategy_name, other.strategy_name]

        return Prediction(
            source=self.source,
            target=self.target,
            predicted_relation=self.predicted_relation,
            prediction_type=PredictionType.ENSEMBLE,
            strategy_name=f"{self.strategy_name}+{other.strategy_name}",
            confidence=combined_confidence,
            reasoning=f"Confirmed by multiple strategies: {self.reasoning}; {other.reasoning}",
            evidence=merged_evidence,
        )

    def __lt__(self, other: 'Prediction') -> bool:
        """Sort by confidence (descending)."""
        return self.confidence > other.confidence  # Higher confidence first

    def __repr__(self) -> str:
        return f"Prediction({self.source} --[{self.predicted_relation}]--> {self.target}, conf={self.confidence:.2f}, via={self.strategy_name})"


@dataclass
class PredictionBatch:
    """A batch of predictions from a strategy or the full Oracle."""

    predictions: list = field(default_factory=list)
    strategy_name: str = "unknown"
    computation_time_ms: float = 0.0

    def add(self, prediction: Prediction):
        """Add a prediction to the batch."""
        self.predictions.append(prediction)

    def merge_duplicates(self) -> 'PredictionBatch':
        """Merge predictions with the same key."""
        by_key = {}
        for pred in self.predictions:
            if pred.key in by_key:
                by_key[pred.key] = by_key[pred.key].merge_with(pred)
            else:
                by_key[pred.key] = pred

        return PredictionBatch(
            predictions=sorted(by_key.values()),
            strategy_name=self.strategy_name,
            computation_time_ms=self.computation_time_ms,
        )

    def filter_by_confidence(self, min_confidence: float) -> 'PredictionBatch':
        """Return only predictions above confidence threshold."""
        return PredictionBatch(
            predictions=[p for p in self.predictions if p.confidence >= min_confidence],
            strategy_name=self.strategy_name,
            computation_time_ms=self.computation_time_ms,
        )

    def top_k(self, k: int) -> list:
        """Return top k predictions by confidence."""
        return sorted(self.predictions)[:k]

    def __len__(self) -> int:
        return len(self.predictions)

    def __iter__(self):
        return iter(self.predictions)
